# A-1: Range Array Divergence V1 vs V2 — Investigation Findings

**Date:** 2026-02-16
**Investigator:** Siddarth Vedi
**Status:** Investigation complete. Bug is latent, not actively triggering.

---

## Summary

V1 (`GenerateNextHand`) and V2 (`GenerateNextHandV2`) use different code paths to produce the `range_array` passed to `_generate_hand_response()`. After hands-on debugging with breakpoints, **no active divergence was found** for the tested Omaha preflop scenarios. The bug is latent — it would activate under specific data conditions (sparse indices, postflop, precision strategies) that the current trainer preflop spots do not trigger.

---

## What Was Tested

| Test | Endpoint | Spot | Variant | Result |
|------|----------|------|---------|--------|
| 1 | V1 `/trainer/generate-next-hand` | `unopened` | Omaha | No divergence |
| 2 | V1 `/trainer/generate-next-hand` | `facingOpen` (BTN vs CO) | Omaha | No divergence |

### Test Parameters

```
variant=omaha, game=cash, site=NoRake, numPlayers=6, stackInBB=100,
BB=0.25, blindStructure=Regular, research=full_tree, openRaise=3.5
```

---

## Debugger Observations

### Range Array (breakpoint at `spot_generation.py:199`)

| Property | `unopened` | `facingOpen` |
|----------|-----------|-------------|
| `range_array.shape` | `(270725,)` | `(270725,)` |
| `range_array.dtype` | `float64` | `float64` |
| `len(range_array) == settings.NUM_COMBOS` | `True` | `True` |
| `'indices' in tree_node` | `False` | `False` |
| `np.count_nonzero(range_array)` | `270725` (all) | `270725` (all) |
| `range_array.min()` | `1.0` | `1.0` |
| `range_array.max()` | `1.0` | `1.0` |

**Conclusion:** All range values are 1.0 (full starting range). No sparse indices present. Array is full `NUM_COMBOS` length (270725 for Omaha).

### Strategy Array (breakpoint at `trainer_helper.py:364`)

| Property | Value |
|----------|-------|
| `decoded_strategy_values.shape` | `(3, 270725)` — 3 actions x 270725 combos |
| `decoded_strategy_values.min` | `-0.0` |
| `decoded_strategy_values.max` | `1.0` |

### EV Array (breakpoint at `trainer_helper.py:364`)

| Property | Value |
|----------|-------|
| `decoded_ev_values.shape` | `(3, 270725)` — 3 actions x 270725 combos |
| `decoded_ev_values.min` | `-5.19` |
| `decoded_ev_values.max` | `12.01` |

**Conclusion:** Strategy and EV arrays are decoded from the same tree node bytes via `decode_strategy_ev()` in both V1 and V2. For preflop, both paths produce identical results.

---

## Why No Divergence Was Found

### V1 Path (`spot_generation.py:199`)

```python
range_array = decode_range(tree_node['range'])
```

Does: brotli decompress → float16→float64 cast → clamp tiny values.

### V2 Path (`spot_generation.py:403`)

```python
range_array = calc_data.rangeResult  # from RangeCalculator.resolve_range()
```

Does: same decode + sparse index expansion + cache + walk-back + suit swaps.

### Why they match for preflop trainer spots:

1. **No sparse indices** — Omaha preflop tree nodes store full 270725-length ranges without compressed `indices`. The `expand_range()` step in V2 is a no-op.

2. **Stored range is all 1.0** — Preflop nodes store the starting range (every hand is possible). V2's walk-back computation would narrow this by multiplying by strategy frequencies of previous actions, but for the hero's perspective at a preflop spot, the stored range is the correct input.

3. **No precision/isomorphism** — `full_tree` Omaha preflop does not use `postflop_only` (precision) strategies, so `apply_swaps()` is never called.

4. **Strategy/EV decoding is identical** — Both V1 and V2 call the same `decode_strategy_ev()` function. V2 pre-decodes and stores results on `calc_data`, but the underlying computation is the same for preflop nodes.

---

## Three Theoretical Sub-Bugs (from original analysis)

| # | Transformation V1 Skips | Active Today? | When It Would Trigger |
|---|------------------------|---------------|----------------------|
| **A** | Sparse index expansion (`expand_range`) | **No** — Omaha preflop nodes have no `indices` field | If tree data is re-imported with sparse storage for preflop nodes |
| **B** | Walk-back range calculation | **No** — hero's starting range is correctly all 1.0 | If trainer expands to postflop streets where range narrowing matters |
| **C** | Precision suit isomorphism swaps (`apply_swaps`) | **No** — `full_tree` preflop doesn't use precision strategies | If trainer supports `postflop_only` (precision) strategies |

---

## Affected Endpoints

| Endpoint | Class | Range Source | Has Bug? | FE Uses? |
|----------|-------|-------------|----------|----------|
| V1 `/trainer/generate-next-hand` | `GenerateNextHand` | `decode_range()` only | Latent | Yes |
| V2 `/trainer/v2/generate-next-hand` | `GenerateNextHandV2` | `RangeCalculator.resolve_range()` | Reference (correct) | Yes |
| V3 `/trainer/v3/generate-next-hand` | `GenerateNextHandV3` | `decode_range()` only | Same latent bug as V1 | No |
| V4 `/trainer/v4/generate-next-hand` | `GenerateNextHandV4` | `RangeCalculator.resolve_range()` | OK (same as V2) | No |

---

## Recommended Fix (Defensive)

Even though the bug is latent, the fix is low-risk and prevents future issues:

**File:** `trainer/views/spot_generation.py`

**V1 (line 199) and V3 (line 590):** Add `expand_range()` after `decode_range()`:

```python
from strategies.utils.unfold_range import decode_range, expand_range

range_array = decode_range(tree_node['range'])
range_array = expand_range(tree_node, range_array)  # handles sparse indices if present
```

`expand_range()` returns the array unchanged when no `indices` key exists, so this is a safe no-op for current data.

---

## Still Untested

- [ ] Holdem variant (`GAME_VARIANT=holdem`) — may have different tree storage patterns
- [ ] Nodes with actual sparse `indices` fields (none found in current Omaha preflop data)
- [ ] V2 endpoint with same params for direct comparison of JSON response
- [ ] Postflop trainer spots (not yet supported by V1)

---

## Files Examined During Investigation

| File | Lines | Purpose |
|------|-------|---------|
| `trainer/views/spot_generation.py` | 185-227 (V1), 373-426 (V2) | Entry points for both paths |
| `trainer/utils/generate_helper.py` | 238-314 | V1's `generate_generic_action_combinations` |
| `trainer/utils/trainer_helper.py` | 303-538 | Shared `_generate_hand_response` |
| `strategies/utils/unfold_range.py` | 280-321 | `decode_range()` and `expand_range()` |
| `strategies/models/strategy_tree_node.py` | 258-451 | `StrategyTreeNode.decode_range()` and `RangeCalculator.resolve_range()` |
| `strategies/services/strategy_tree/decoder.py` | 45-134 | V2's `StrategyNodeDecoder.decode()` |
| `strategies/services/strategy_treenode_resolver.py` | 168-204 | V2's `resolve_node()` orchestrator |
| `strategies/repositories/strategy_repository.py` | 478-505 | `get_tree_node_by_combo()` — no projection, full doc returned |
